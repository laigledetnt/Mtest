<!DOCTYPE html>
<html lang="fr">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
<title>Minecraft Simplifié</title>
<style>
* {
  margin: 0;
  padding: 0;
  box-sizing: border-box;
  -webkit-user-select: none;
  user-select: none;
}

body {
  overflow: hidden;
  font-family: 'Courier New', monospace;
  background: #87CEEB;
}

#canvas {
  display: block;
  touch-action: none;
}

#ui {
  position: fixed;
  top: 0;
  left: 0;
  width: 100%;
  height: 100%;
  pointer-events: none;
  z-index: 100;
}

#inventory {
  position: absolute;
  bottom: 20px;
  left: 50%;
  transform: translateX(-50%);
  display: flex;
  gap: 10px;
  pointer-events: all;
}

.inv-slot {
  width: 60px;
  height: 60px;
  border: 3px solid #333;
  background: rgba(139, 139, 139, 0.8);
  cursor: pointer;
  transition: all 0.2s;
  display: flex;
  align-items: center;
  justify-content: center;
  font-size: 12px;
  color: white;
  text-shadow: 2px 2px 2px black;
  font-weight: bold;
}

.inv-slot.active {
  border-color: #FFD700;
  box-shadow: 0 0 10px #FFD700;
  transform: scale(1.1);
}

.inv-slot:hover {
  transform: scale(1.05);
}

.joystick {
  position: absolute;
  width: 120px;
  height: 120px;
  pointer-events: all;
  opacity: 0.6;
}

#leftJoy {
  bottom: 10px;
  left: 20px;
}

#rightJoy {
  bottom: 10px;
  right: 20px;
}

.joy-base {
  width: 100%;
  height: 100%;
  background: rgba(100, 100, 100, 0.5);
  border: 3px solid rgba(255, 255, 255, 0.7);
  border-radius: 50%;
  position: relative;
}

.joy-stick {
  width: 50px;
  height: 50px;
  background: rgba(200, 200, 200, 0.8);
  border: 2px solid white;
  border-radius: 50%;
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  transition: all 0.1s;
}

#jumpBtn {
  position: absolute;
  bottom: 113px;
  right: 30px;
  width: 70px;
  height: 70px;
  background: rgba(100, 200, 100, 0.7);
  border: 3px solid white;
  border-radius: 50%;
  pointer-events: all;
  display: flex;
  align-items: center;
  justify-content: center;
  color: white;
  font-weight: bold;
  font-size: 14px;
  cursor: pointer;
  transition: all 0.2s;
}

#jumpBtn:active {
  background: rgba(100, 255, 100, 0.9);
  transform: scale(0.95);
}

#crosshair {
  position: absolute;
  top: 50%;
  left: 50%;
  transform: translate(-50%, -50%);
  width: 20px;
  height: 20px;
  pointer-events: none;
}

#crosshair::before,
#crosshair::after {
  content: '';
  position: absolute;
  background: white;
}

#crosshair::before {
  width: 20px;
  height: 2px;
  top: 9px;
  left: 0;
}

#crosshair::after {
  width: 2px;
  height: 20px;
  top: 0;
  left: 9px;
}

#info {
  position: absolute;
  top: 10px;
  left: 10px;
  color: white;
  text-shadow: 2px 2px 4px black;
  font-size: 14px;
  pointer-events: none;
}

@media (max-width: 768px) {
  .inv-slot {
    width: 50px;
    height: 50px;
    font-size: 10px;
  }
}
</style>
</head>
<body>
<canvas id="canvas"></canvas>
<div id="ui">
  <div id="crosshair"></div>
  <div id="info">
    <div>Blocs: <span id="blockCount">0</span></div>
    <div id="actionText"></div>
  </div>
  
  <div id="inventory"></div>
  
  <div class="joystick" id="leftJoy">
    <div class="joy-base">
      <div class="joy-stick" id="leftStick"></div>
    </div>
  </div>
  
  <div class="joystick" id="rightJoy">
    <div class="joy-base">
      <div class="joy-stick" id="rightStick"></div>
    </div>
  </div>
  
  <button id="jumpBtn">SAUT</button>
</div>

<script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
<script>
const scene = new THREE.Scene();
scene.background = new THREE.Color(0x87CEEB);
scene.fog = new THREE.Fog(0x87CEEB, 30, 80);

const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
const renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('canvas'), antialias: true });
renderer.setSize(window.innerWidth, window.innerHeight);
renderer.shadowMap.enabled = true;
renderer.shadowMap.type = THREE.PCFSoftShadowMap;

const BLOCK_SIZE = 2;
const GRID_SIZE = 20;
const PLAYER_HEIGHT = 3;
const PLAYER_RADIUS = 0.5;
const GRAVITY = -20;
const JUMP_FORCE = 10;
const MOVE_SPEED = 5;
const LOOK_SPEED = 2;
const REACH_DISTANCE = 10;

const blockTypes = [
  { name: 'Herbe', color: 0x7CFC00 },
  { name: 'Terre', color: 0x8B4513 },
  { name: 'Pierre', color: 0x808080 },
  { name: 'Bois', color: 0xDEB887 },
  { name: 'Sable', color: 0xF4A460 }
];

let selectedBlock = 0;
let blocks = [];
let velocity = { x: 0, y: 0, z: 0 };
let playerPos = { x: 0, y: 10, z: 0 };
let rotation = { yaw: 0, pitch: 0 };
let isGrounded = false;
let canJump = true;
let lastJumpTime = 0;

let leftJoy = { active: false, x: 0, y: 0, id: null };
let rightJoy = { active: false, x: 0, y: 0, id: null };

let longPressTimer = null;
let longPressActive = false;
let touchStartPos = null;
let touchMoved = false;
let actionCooldown = false;

const ambLight = new THREE.AmbientLight(0xffffff, 0.6);
scene.add(ambLight);

const dirLight = new THREE.DirectionalLight(0xffffff, 0.6);
dirLight.position.set(50, 100, 30);
dirLight.castShadow = true;
dirLight.shadow.camera.left = -50;
dirLight.shadow.camera.right = 50;
dirLight.shadow.camera.top = 50;
dirLight.shadow.camera.bottom = -50;
dirLight.shadow.camera.near = 0.5;
dirLight.shadow.camera.far = 200;
dirLight.shadow.mapSize.width = 2048;
dirLight.shadow.mapSize.height = 2048;
scene.add(dirLight);

for (let x = -GRID_SIZE / 2; x < GRID_SIZE / 2; x++) {
  for (let z = -GRID_SIZE / 2; z < GRID_SIZE / 2; z++) {
    addBlock(x * BLOCK_SIZE, -BLOCK_SIZE, z * BLOCK_SIZE, 0);
  }
}

for (let i = 0; i < 15; i++) {
  const x = Math.floor(Math.random() * 10 - 5) * BLOCK_SIZE;
  const z = Math.floor(Math.random() * 10 - 5) * BLOCK_SIZE;
  const type = Math.floor(Math.random() * blockTypes.length);
  addBlock(x, BLOCK_SIZE, z, type);
}

const invContainer = document.getElementById('inventory');
blockTypes.forEach((type, i) => {
  const slot = document.createElement('div');
  slot.className = 'inv-slot' + (i === 0 ? ' active' : '');
  slot.textContent = type.name;
  slot.style.background = `rgba(${(type.color >> 16) & 255}, ${(type.color >> 8) & 255}, ${type.color & 255}, 0.8)`;
  slot.onclick = () => selectBlock(i);
  invContainer.appendChild(slot);
});

function selectBlock(index) {
  selectedBlock = index;
  document.querySelectorAll('.inv-slot').forEach((slot, i) => {
    slot.classList.toggle('active', i === index);
  });
}

function addBlock(x, y, z, type) {
  const geo = new THREE.BoxGeometry(BLOCK_SIZE, BLOCK_SIZE, BLOCK_SIZE);
  const mat = new THREE.MeshLambertMaterial({ color: blockTypes[type].color });
  const mesh = new THREE.Mesh(geo, mat);
  
  mesh.position.set(
    Math.round(x / BLOCK_SIZE) * BLOCK_SIZE,
    Math.round(y / BLOCK_SIZE) * BLOCK_SIZE,
    Math.round(z / BLOCK_SIZE) * BLOCK_SIZE
  );
  
  mesh.castShadow = true;
  mesh.receiveShadow = true;
  scene.add(mesh);
  
  blocks.push({ mesh, type, pos: mesh.position.clone() });
  updateBlockCount();
}

function removeBlock(block) {
  scene.remove(block.mesh);
  blocks = blocks.filter(b => b !== block);
  updateBlockCount();
}

function updateBlockCount() {
  document.getElementById('blockCount').textContent = blocks.length;
}

function raycast(screenX, screenY) {
  const raycaster = new THREE.Raycaster();
  
  const mouse = new THREE.Vector2();
  mouse.x = (screenX / window.innerWidth) * 2 - 1;
  mouse.y = -(screenY / window.innerHeight) * 2 + 1;
  
  raycaster.setFromCamera(mouse, camera);
  const intersects = raycaster.intersectObjects(blocks.map(b => b.mesh));
  
  if (intersects.length > 0 && intersects[0].distance <= REACH_DISTANCE) {
    return { block: blocks.find(b => b.mesh === intersects[0].object), face: intersects[0].face, point: intersects[0].point };
  }
  return null;
}

function placeBlockAtPosition(screenX, screenY) {
  if (actionCooldown) return;
  
  const hit = raycast(screenX, screenY);
  if (hit && hit.face) {
    const normal = hit.face.normal.clone();
    const pos = hit.block.pos.clone().add(normal.multiplyScalar(BLOCK_SIZE));
    
    const exists = blocks.some(b => 
      Math.abs(b.pos.x - pos.x) < 0.1 && 
      Math.abs(b.pos.y - pos.y) < 0.1 && 
      Math.abs(b.pos.z - pos.z) < 0.1
    );
    
    if (exists) {
      showAction('Bloc déjà présent!');
      return;
    }
    
    const dx = Math.abs(pos.x - playerPos.x);
    const dy = Math.abs(pos.y - playerPos.y);
    const dz = Math.abs(pos.z - playerPos.z);
    
    if (dx < BLOCK_SIZE && dy < PLAYER_HEIGHT && dz < BLOCK_SIZE) {
      showAction('Trop proche!');
      return;
    }
    
    addBlock(pos.x, pos.y, pos.z, selectedBlock);
    showAction('Bloc placé');
    
    actionCooldown = true;
    setTimeout(() => actionCooldown = false, 300);
  }
}

function destroyBlockAtPosition(screenX, screenY) {
  if (actionCooldown) return;
  
  const hit = raycast(screenX, screenY);
  if (hit) {
    removeBlock(hit.block);
    showAction('Bloc détruit');
    
    actionCooldown = true;
    setTimeout(() => actionCooldown = false, 300);
  }
}

function showAction(text) {
  const el = document.getElementById('actionText');
  el.textContent = text;
  setTimeout(() => el.textContent = '', 1000);
}

function checkCollision(pos) {
  for (const block of blocks) {
    const dx = Math.abs(pos.x - block.pos.x);
    const dy = Math.abs(pos.y - block.pos.y);
    const dz = Math.abs(pos.z - block.pos.z);
    
    if (dx < BLOCK_SIZE / 2 + PLAYER_RADIUS && 
        dy < BLOCK_SIZE / 2 + PLAYER_HEIGHT / 2 && 
        dz < BLOCK_SIZE / 2 + PLAYER_RADIUS) {
      return block;
    }
  }
  return null;
}

function jump() {
  const now = Date.now();
  if (isGrounded && canJump && now - lastJumpTime > 300) {
    velocity.y = JUMP_FORCE;
    isGrounded = false;
    canJump = false;
    lastJumpTime = now;
    setTimeout(() => canJump = true, 300);
  }
}

let jumpButtonPressed = false;

function getTouchPos(e, rect) {
  return {
    x: (e.clientX - rect.left - rect.width / 2) / (rect.width / 2),
    y: (e.clientY - rect.top - rect.height / 2) / (rect.height / 2)
  };
}

function handleJoystick(joy, element, stick, e) {
  const rect = element.getBoundingClientRect();
  const pos = getTouchPos(e, rect);
  const dist = Math.min(1, Math.sqrt(pos.x * pos.x + pos.y * pos.y));
  
  joy.x = pos.x * dist;
  joy.y = pos.y * dist;
  
  stick.style.transform = `translate(${joy.x * 35}px, ${joy.y * 35}px)`;
}

document.getElementById('leftJoy').addEventListener('touchstart', e => {
  e.preventDefault();
  leftJoy.active = true;
  leftJoy.id = e.touches[0].identifier;
  handleJoystick(leftJoy, e.currentTarget, document.getElementById('leftStick'), e.touches[0]);
});

document.getElementById('leftJoy').addEventListener('mousedown', e => {
  e.preventDefault();
  leftJoy.active = true;
  leftJoy.id = 'mouse';
  handleJoystick(leftJoy, e.currentTarget, document.getElementById('leftStick'), e);
});

document.getElementById('rightJoy').addEventListener('touchstart', e => {
  e.preventDefault();
  rightJoy.active = true;
  rightJoy.id = e.touches[0].identifier;
  handleJoystick(rightJoy, e.currentTarget, document.getElementById('rightStick'), e.touches[0]);
});

document.getElementById('rightJoy').addEventListener('mousedown', e => {
  e.preventDefault();
  rightJoy.active = true;
  rightJoy.id = 'mouse';
  handleJoystick(rightJoy, e.currentTarget, document.getElementById('rightStick'), e);
});

document.addEventListener('touchmove', e => {
  if (touchStartPos && !leftJoy.active && !rightJoy.active) {
    const clientX = e.touches[0].clientX;
    const clientY = e.touches[0].clientY;
    
    const dx = Math.abs(clientX - touchStartPos.x);
    const dy = Math.abs(clientY - touchStartPos.y);
    
    if (dx > 10 || dy > 10) {
      touchMoved = true;
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    }
  }
  
  if (leftJoy.active) {
    const touch = Array.from(e.touches).find(t => t.identifier === leftJoy.id);
    if (touch) handleJoystick(leftJoy, document.getElementById('leftJoy'), document.getElementById('leftStick'), touch);
  }
  
  if (rightJoy.active) {
    const touch = Array.from(e.touches).find(t => t.identifier === rightJoy.id);
    if (touch) handleJoystick(rightJoy, document.getElementById('rightJoy'), document.getElementById('rightStick'), touch);
  }
});

document.addEventListener('mousemove', e => {
  if (touchStartPos && !leftJoy.active && !rightJoy.active) {
    const dx = Math.abs(e.clientX - touchStartPos.x);
    const dy = Math.abs(e.clientY - touchStartPos.y);
    
    if (dx > 10 || dy > 10) {
      touchMoved = true;
      if (longPressTimer) {
        clearTimeout(longPressTimer);
        longPressTimer = null;
      }
    }
  }
  
  if (leftJoy.active) {
    handleJoystick(leftJoy, document.getElementById('leftJoy'), document.getElementById('leftStick'), e);
  }
  
  if (rightJoy.active) {
    handleJoystick(rightJoy, document.getElementById('rightJoy'), document.getElementById('rightStick'), e);
  }
});

document.addEventListener('touchstart', e => {
  if (e.target.closest('.joystick') || e.target.closest('#jumpBtn') || e.target.closest('.inv-slot')) {
    return;
  }
  
  if (actionCooldown || touchStartPos) return;
  
  const clientX = e.touches[0].clientX;
  const clientY = e.touches[0].clientY;
  
  touchStartPos = { x: clientX, y: clientY };
  touchMoved = false;
  longPressActive = false;
  
  longPressTimer = setTimeout(() => {
    if (!touchMoved && !actionCooldown) {
      longPressActive = true;
      destroyBlockAtPosition(touchStartPos.x, touchStartPos.y);
    }
  }, 600);
});

document.addEventListener('mousedown', e => {
  if (e.target.closest('.joystick') || e.target.closest('#jumpBtn') || e.target.closest('.inv-slot')) {
    return;
  }
  
  if (actionCooldown || touchStartPos) return;
  
  touchStartPos = { x: e.clientX, y: e.clientY };
  touchMoved = false;
  longPressActive = false;
  
  longPressTimer = setTimeout(() => {
    if (!touchMoved && !actionCooldown) {
      longPressActive = true;
      destroyBlockAtPosition(touchStartPos.x, touchStartPos.y);
    }
  }, 600);
});

document.addEventListener('touchend', e => {
  const touches = Array.from(e.touches);
  
  if (leftJoy.active && !touches.some(t => t.identifier === leftJoy.id)) {
    leftJoy.active = false;
    leftJoy.x = leftJoy.y = 0;
    document.getElementById('leftStick').style.transform = 'translate(0, 0)';
  }
  
  if (rightJoy.active && !touches.some(t => t.identifier === rightJoy.id)) {
    rightJoy.active = false;
    rightJoy.x = rightJoy.y = 0;
    document.getElementById('rightStick').style.transform = 'translate(0, 0)';
  }
  
  if (longPressTimer) {
    clearTimeout(longPressTimer);
    longPressTimer = null;
  }
  
  if (!longPressActive && touchStartPos && !touchMoved && !actionCooldown && !e.target.closest('.joystick') && !e.target.closest('#jumpBtn') && !e.target.closest('.inv-slot')) {
    placeBlockAtPosition(touchStartPos.x, touchStartPos.y);
  }
  
  longPressActive = false;
  touchStartPos = null;
  touchMoved = false;
});

document.addEventListener('mouseup', e => {
  if (leftJoy.active) {
    leftJoy.active = false;
    leftJoy.x = leftJoy.y = 0;
    document.getElementById('leftStick').style.transform = 'translate(0, 0)';
  }
  
  if (rightJoy.active) {
    rightJoy.active = false;
    rightJoy.x = rightJoy.y = 0;
    document.getElementById('rightStick').style.transform = 'translate(0, 0)';
  }
  
  if (longPressTimer) {
    clearTimeout(longPressTimer);
    longPressTimer = null;
  }
  
  if (!longPressActive && touchStartPos && !touchMoved && !actionCooldown && !e.target.closest('.joystick') && !e.target.closest('#jumpBtn') && !e.target.closest('.inv-slot')) {
    placeBlockAtPosition(touchStartPos.x, touchStartPos.y);
  }
  
  longPressActive = false;
  touchStartPos = null;
  touchMoved = false;
});

document.getElementById('jumpBtn').addEventListener('touchstart', e => {
  e.preventDefault();
  if (!jumpButtonPressed) {
    jumpButtonPressed = true;
    jump();
  }
});

document.getElementById('jumpBtn').addEventListener('touchend', e => {
  e.preventDefault();
  jumpButtonPressed = false;
});

document.getElementById('jumpBtn').addEventListener('mousedown', e => {
  e.preventDefault();
  if (!jumpButtonPressed) {
    jumpButtonPressed = true;
    jump();
  }
});

document.getElementById('jumpBtn').addEventListener('mouseup', e => {
  e.preventDefault();
  jumpButtonPressed = false;
});

let lastTime = performance.now();

function animate() {
  requestAnimationFrame(animate);
  
  const now = performance.now();
  const dt = Math.min((now - lastTime) / 1000, 0.1);
  lastTime = now;
  
  const forward = new THREE.Vector3(0, 0, -1).applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation.yaw);
  const right = new THREE.Vector3(1, 0, 0).applyAxisAngle(new THREE.Vector3(0, 1, 0), rotation.yaw);
  
  velocity.x = (-leftJoy.y * forward.x + leftJoy.x * right.x) * MOVE_SPEED;
  velocity.z = (-leftJoy.y * forward.z + leftJoy.x * right.z) * MOVE_SPEED;
  
  rotation.yaw -= rightJoy.x * LOOK_SPEED * dt;
  rotation.pitch = Math.max(-Math.PI / 3, Math.min(Math.PI / 3, rotation.pitch - rightJoy.y * LOOK_SPEED * dt));
  
  if (!isGrounded) {
    velocity.y += GRAVITY * dt;
  }
  
  const newPos = {
    x: playerPos.x + velocity.x * dt,
    y: playerPos.y + velocity.y * dt,
    z: playerPos.z + velocity.z * dt
  };
  
  const testX = { ...playerPos, x: newPos.x };
  if (!checkCollision(testX)) {
    playerPos.x = newPos.x;
  } else {
    velocity.x = 0;
  }
  
  const testY = { ...playerPos, y: newPos.y };
  const collisionY = checkCollision(testY);
  
  if (!collisionY) {
    playerPos.y = newPos.y;
    isGrounded = false;
  } else {
    if (velocity.y < 0) {
      isGrounded = true;
      playerPos.y = collisionY.pos.y + BLOCK_SIZE / 2 + PLAYER_HEIGHT / 2 + 0.01;
    } else if (velocity.y > 0) {
      playerPos.y = collisionY.pos.y - BLOCK_SIZE / 2 - PLAYER_HEIGHT / 2 - 0.01;
    }
    velocity.y = 0;
  }
  
  const testZ = { ...playerPos, z: newPos.z };
  if (!checkCollision(testZ)) {
    playerPos.z = newPos.z;
  } else {
    velocity.z = 0;
  }
  
  if (playerPos.y <= 0) {
    playerPos.y = 0;
    isGrounded = true;
    velocity.y = 0;
  }
  
  camera.position.set(playerPos.x, playerPos.y + PLAYER_HEIGHT / 2, playerPos.z);
  camera.rotation.order = 'YXZ';
  camera.rotation.y = rotation.yaw;
  camera.rotation.x = rotation.pitch;
  
  renderer.render(scene, camera);
}

window.addEventListener('resize', () => {
  camera.aspect = window.innerWidth / window.innerHeight;
  camera.updateProjectionMatrix();
  renderer.setSize(window.innerWidth, window.innerHeight);
});

animate();
</script>
</body>
</html>
